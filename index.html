<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta name="theme-color" content="#0b1020" />
    <meta name="color-scheme" content="dark" />
    <meta name="robots" content="index, follow" />
    <title>Coming Soon</title>
    <meta name="description" content="We're building the toolbox of tomorrow. Get in touch in the meantime." />
    <link rel="canonical" href="https://theairbrushcompany.co.uk/" />
    <meta property="og:title" content="Coming Soon" />
    <meta property="og:description" content="We're building the toolbox of tomorrow. Get in touch in the meantime." />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://theairbrushcompany.co.uk/" />
    <meta property="og:site_name" content="xenargs softworks" />
    <meta property="og:image" content="https://theairbrushcompany.co.uk/og-image.jpg" />
    <meta name="twitter:image" content="https://theairbrushcompany.co.uk/og-image.jpg" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="author" content="xenargs softworks" />
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ctext y='52' font-size='52'%3E%F0%9F%8E%A8%3C/text%3E%3C/svg%3E" />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Orbitron:wght@600;700;800&display=swap" rel="stylesheet" />

    <link rel="stylesheet" href="./styles.css" />
  </head>
  <body>
    <div class="bg">
      <canvas id="stars" aria-hidden="true"></canvas>
      <div class="blob b1"></div>
      <div class="blob b2"></div>
      <div class="blob b3"></div>
      <div class="vignette"></div>
    </div>

    <main class="card" role="main">
      <div class="logo" aria-label="Brand"><span class="logo-text">xenargs softworks</span></div>
      <h1>Coming Soon</h1>
      <p class="tagline">We're building the toolbox of tomorrow. In the meantime, say hi:</p>

      <ul class="contacts">
        <li>
          <a class="contact" href="mailto:xenargs@theairbrushcompany.co.uk">
            <svg aria-hidden="true" viewBox="0 0 24 24" width="20" height="20" fill="currentColor">
              <path d="M2 6.75A2.75 2.75 0 0 1 4.75 4h14.5A2.75 2.75 0 0 1 22 6.75v10.5A2.75 2.75 0 0 1 19.25 20H4.75A2.75 2.75 0 0 1 2 17.25V6.75Zm2.75-.25a.25.25 0 0 0-.25.25v.37l7.14 4.47c.23.14.49.14.72 0L20.5 7.06v-.31a.25.25 0 0 0-.25-.25H4.75Zm15.5 3.13-6.82 4.27a2.75 2.75 0 0 1-2.86 0L3.75 9.63v7.62c0 .14.11.25.25.25h14.5c.14 0 .25-.11.25-.25V9.63Z"/>
            </svg>
            <span>xenargs@theairbrushcompany.co.uk</span>
          </a>
        </li>
      </ul>

      <p class="small">Â© <span id="year"></span> xenargs softworks. All rights reserved. <span class="version">v1.1</span></p>
    </main>

    <script>
      // Year stamp
      const y = document.getElementById('year');
      if (y) y.textContent = String(new Date().getFullYear());

      const reduceMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      // Smooth parallax tilt with easing + foil highlight mapping
      (function initTilt() {
        if (reduceMotion) return;
        const card = document.querySelector('.card');
        if (!card) return;
        const logo = document.querySelector('.logo');
        const clamp = (n, min, max) => Math.min(Math.max(n, min), max);
        const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        let targetX = 0, targetY = 0; // desired tilt angles
        let currentX = 0, currentY = 0; // animated tilt angles
        let angleTarget = 0, angleCurrent = 0; // foil angle (deg)
        let spotXTarget = 50, spotYTarget = 50; // foil spot (%)
        let spotXCurrent = 50, spotYCurrent = 50; // animated foil spot (%)
        let rafId = 0;
        let hasDeviceTilt = false;
        let hasDeviceMotion = false;
        let baselineGamma = null, baselineBeta = null; // center calibration
        let lastGamma = 0, lastBeta = 0;
        let motionBtn = null; let motionBtnShown = false;
        let calibrateBtn = null;
        let tipEl = null; let tipShown = false;

        function lerpAngle(current, target, t) {
          // shortest path interpolation in degrees
          let diff = ((target - current + 540) % 360) - 180;
          return current + diff * t;
        }

        function animate(ts = 0) {
          const ease = 0.10; // tilt smoothing
          const foilEase = 0.06; // foil smoothing (slower for more relaxed motion)
          currentX += (targetX - currentX) * ease;
          currentY += (targetY - currentY) * ease;
          card.style.transform = `rotateX(${currentX.toFixed(3)}deg) rotateY(${currentY.toFixed(3)}deg)`;

          // Foil smoothing and updates
          if (isTouch && !hasDeviceTilt) {
            // Fallback: gentle autonomous motion if device tilt not available/granted
            const t = ts * 0.001;
            angleTarget = (t * 15) % 360;
            spotXTarget = 50 + Math.sin(t * 0.45) * 10;
            spotYTarget = 50 + Math.cos(t * 0.60) * 8;
          }

          angleCurrent = lerpAngle(angleCurrent, angleTarget, foilEase);
          spotXCurrent += (spotXTarget - spotXCurrent) * foilEase;
          spotYCurrent += (spotYTarget - spotYCurrent) * foilEase;

          card.style.setProperty('--angle', angleCurrent.toFixed(1) + 'deg');
          if (logo) logo.style.setProperty('--angle', angleCurrent.toFixed(1) + 'deg');
          card.style.setProperty('--spotX', spotXCurrent.toFixed(1) + '%');
          card.style.setProperty('--spotY', spotYCurrent.toFixed(1) + '%');
          rafId = requestAnimationFrame(animate);
        }

        function onMove(e) {
          const r = card.getBoundingClientRect();
          const cx = r.left + r.width / 2;
          const cy = r.top + r.height / 2;
          const dx = (e.clientX - cx) / (r.width / 2);
          const dy = (e.clientY - cy) / (r.height / 2);
          targetX = clamp(-dy * 6, -8, 8);
          targetY = clamp(dx * 7, -9, 9);

          // Update foil angle globally (no localized mask)
          const angle = Math.atan2(e.clientY - cy, e.clientX - cx) * 180 / Math.PI + 180;
          angleTarget = angle;
          // Move specular spot opposite to tilt like a real card (set targets; smoothing occurs in animate)
          spotXTarget = 50 + (-targetY / 9) * 25; // map tilt to percentage
          spotYTarget = 50 + (targetX / 8) * 18;
        }

        function reset() {
          targetX = 0; targetY = 0;
        }

        animate();
        if (!isTouch) {
          window.addEventListener('mousemove', onMove);
          window.addEventListener('mouseleave', reset);
        }

        // Device tilt (gyro) for touch devices
        function onOrientation(ev) {
          if (!ev) return;
          let gamma = typeof ev.gamma === 'number' ? ev.gamma : 0; // left-right tilt (-90..90)
          let beta = typeof ev.beta === 'number' ? ev.beta : 0;   // front-back tilt (-180..180)
          lastGamma = gamma; lastBeta = beta;
          if (baselineGamma === null || baselineBeta === null) {
            baselineGamma = gamma;
            baselineBeta = beta;
          }
          const dGamma = gamma - baselineGamma; // horizontal
          const dBeta = beta - baselineBeta;     // vertical

          // Map deltas to card tilt degrees (clamped)
          const targetXDeg = clamp((-dBeta) * (8 / 30), -8, 8);   // forward/back maps to rotateX
          const targetYDeg = clamp((dGamma) * (9 / 30), -9, 9);   // left/right maps to rotateY
          targetX = targetXDeg;
          targetY = targetYDeg;

          // Foil angle points along tilt vector; convert to 0..360
          const ang = Math.atan2(-targetXDeg, targetYDeg) * 180 / Math.PI;
          angleTarget = (ang + 360) % 360;
          // Specular spot responds opposite to tilt like with mouse
          spotXTarget = 50 + (-targetYDeg / 9) * 25;
          spotYTarget = 50 + (targetXDeg / 8) * 18;
          hasDeviceTilt = true;
        }

        function attachOrientation() {
          try {
            window.addEventListener('deviceorientation', onOrientation, true);
          } catch (_) { /* no-op */ }
        }

        // DeviceMotion fallback, derive tilt from acceleration including gravity
        function onMotion(ev) {
          if (!ev || !ev.accelerationIncludingGravity) return;
          const g = ev.accelerationIncludingGravity;
          const ax = typeof g.x === 'number' ? g.x : 0;
          const ay = typeof g.y === 'number' ? g.y : 0;
          const az = typeof g.z === 'number' ? g.z : 0;
          // Compute pitch/roll in degrees; simple mapping for portrait orientation
          const roll = Math.atan2(ay, az) * 180 / Math.PI;     // left/right
          const pitch = Math.atan2(-ax, Math.hypot(ay, az)) * 180 / Math.PI; // forward/back

          const targetXDeg = clamp(pitch * (8 / 30), -8, 8);
          const targetYDeg = clamp(roll * (9 / 30), -9, 9);
          targetX = targetXDeg;
          targetY = targetYDeg;

          const ang = Math.atan2(-targetXDeg, targetYDeg) * 180 / Math.PI;
          angleTarget = (ang + 360) % 360;
          spotXTarget = 50 + (-targetYDeg / 9) * 25;
          spotYTarget = 50 + (targetXDeg / 8) * 18;
          hasDeviceMotion = true;
          hasDeviceTilt = true;
        }

        function attachMotion() {
          try {
            window.addEventListener('devicemotion', onMotion, true);
          } catch (_) { /* no-op */ }
        }

        function createMotionButton() {
          if (motionBtnShown) return;
          motionBtn = document.createElement('button');
          motionBtn.className = 'motion-btn';
          motionBtn.type = 'button';
          motionBtn.textContent = 'Enable motion';
          card.appendChild(motionBtn);
          motionBtnShown = true;
          motionBtn.addEventListener('click', async () => {
            try {
              if ('DeviceOrientationEvent' in window && typeof DeviceOrientationEvent.requestPermission === 'function') {
                const res = await DeviceOrientationEvent.requestPermission();
                if (res !== 'granted') return;
              }
              attachOrientation();
              attachMotion();
            } finally {
              if (motionBtn) motionBtn.remove();
            }
          }, { once: true });
        }

        function createCalibrateButton() {
          if (calibrateBtn) return;
          calibrateBtn = document.createElement('button');
          calibrateBtn.className = 'cal-btn';
          calibrateBtn.type = 'button';
          calibrateBtn.textContent = 'Calibrate';
          card.appendChild(calibrateBtn);
          calibrateBtn.addEventListener('click', () => {
            // Set baseline to last observed values
            baselineGamma = lastGamma;
            baselineBeta = lastBeta;
            targetX = 0; targetY = 0;
          });
        }

        function showMotionTip() {
          if (tipShown) return;
          tipEl = document.createElement('div');
          tipEl.className = 'motion-tip';
          tipEl.innerHTML = 'No motion detected. In some browsers (e.g., Brave), enable Motion Sensors in Site settings.';
          card.appendChild(tipEl);
          tipShown = true;
          // Auto-hide after a while
          setTimeout(() => { if (tipEl) tipEl.remove(); }, 7000);
        }

        if (isTouch) {
          // Always render controls on touch: enable + calibrate
          createMotionButton();
          createCalibrateButton();
          // Prefer orientation if available
          if ('DeviceOrientationEvent' in window) {
            const needsPermission = typeof DeviceOrientationEvent.requestPermission === 'function';
            if (needsPermission) {
              // iOS: wait for user gesture via the button
            } else {
              // Android/others
              attachOrientation();
              attachMotion();
            }
          } else if ('DeviceMotionEvent' in window) {
            attachMotion();
          }

          // If no events arrive shortly (e.g., Brave blocks sensors), show a brief tip
          setTimeout(() => {
            if (!hasDeviceTilt) showMotionTip();
          }, 1500);
        }
      })();

      // Lightweight starfield background
      (function initStars() {
        const canvas = document.getElementById('stars');
        if (!canvas || reduceMotion) return;
        const ctx = canvas.getContext('2d');
        const DPR = Math.min(window.devicePixelRatio || 1, 2);
        let width = 0, height = 0, stars = [], rafId = 0;

        function resize() {
          const { innerWidth, innerHeight } = window;
          width = innerWidth; height = innerHeight;
          canvas.width = Math.floor(width * DPR);
          canvas.height = Math.floor(height * DPR);
          canvas.style.width = width + 'px';
          canvas.style.height = height + 'px';
          ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
          const area = width * height;
          const isSmall = width <= 480;
          const base = isSmall ? (area / 14000) : (area / 9000);
          const cap = isSmall ? 140 : 240;
          const starCount = Math.min(Math.floor(base), cap);
          stars = Array.from({ length: starCount }, () => ({
            x: Math.random() * width,
            y: Math.random() * height,
            r: Math.random() * 1.2 + 0.2,
            a: Math.random() * Math.PI * 2,
            s: Math.random() * 0.4 + 0.05,
          }));
        }

        function draw() {
          ctx.clearRect(0, 0, width, height);
          ctx.fillStyle = 'rgba(255,255,255,0.9)';
          for (const star of stars) {
            star.a += star.s * 0.02;
            const twinkle = 0.3 + Math.abs(Math.sin(star.a)) * 0.7;
            ctx.globalAlpha = twinkle * 0.7;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.globalAlpha = 1;
          rafId = requestAnimationFrame(draw);
        }

        resize();
        draw();
        window.addEventListener('resize', () => {
          cancelAnimationFrame(rafId);
          resize();
          draw();
        });
      })();
    </script>

    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "Organization",
        "name": "xenargs softworks",
        "url": "https://theairbrushcompany.co.uk/",
        "email": "mailto:xenargs@theairbrushcompany.co.uk",
        "sameAs": [
          "https://github.com/xenargs"
        ]
      }
    </script>
  </body>
</html>


